// Generated by CoffeeScript 1.10.0
(function () {
  var AnomAPI, hubotRouter, opsa, pleaseWaitMsg, request, utils;
  request = require('request');
  require('request-debug')(request);
  opsa = require('opsa');
  utils = require('utils');
  pleaseWaitMsg = 'Please wait...';
  hubotRouter = new utils.RegistrationHandler();
  AnomAPI = function (xsrfToken, jSessionId) {
    if (xsrfToken) {
      this.xsrfToken = xsrfToken.slice(1, -1);
    }
    if (jSessionId) {
      this.jSessionId = jSessionId;
    }
  };
  AnomAPI.prototype.constructor = AnomAPI;
  AnomAPI.prototype.requestPrimaryData = function () {
    var anomUrl, createAnomaliesApiUri, oneHourAgo, self;
    oneHourAgo = utils.getOneHourAgoTS();
    createAnomaliesApiUri = function (startTime, endTime) {
      return "/rest/getQueryResult?aqlQuery=%5Banomalies%5BattributeQuery(%7Bopsa_collection_anomalies%7D,+%7B%7D,+%7Bi.anomaly_id%7D)%5D()%5D+&endTime=" + endTime + "&granularity=0&pageIndex=1&paramsMap=%7B%22$drill_dest%22:%22AnomalyInstance%22,%22$drill_label%22:%22opsa_collection_anomalies_description%22,%22$drill_value%22:%22opsa_collection_anomalies_anomaly_id%22,%22$limit%22:%22500%22,%22$interval%22:300,%22$offset%22:0,%22$N%22:5,%22$pctile%22:10,%22$timeoffset%22:0,%22$starttimeoffset%22:0,%22$endtimeoffset%22:0,%22$timeout%22:0,%22$drill_type%22:%22%22,%22$problemtime%22:1463653196351,%22$aggregate_playback_flag%22:null%7D&queryType=generic&startTime=" + startTime + "&timeZoneOffset=-180&timeout=10&visualType=table";
    };
    anomUrl = opsa.getUrl() + createAnomaliesApiUri(oneHourAgo, utils.now);
    this.sJar = opsa.generateJar(this.jSessionId, anomUrl);
    this.sHeaders = {
      'XSRFToken': this.xsrfToken
    };
    self = this;
    return utils.requestp({
      url: anomUrl,
      jar: this.sJar,
      method: 'POST',
      headers: this.sHeaders
    });
  };
  AnomAPI.prototype.getMetricsDescUrl = function (parsedInfo) {
    var endTime, metricsUri, now, ref;
    now = new Date().getTime();
    endTime = (ref = parsedInfo.inactiveTime) != null ? ref : now;
    metricsUri = "/rest/getQueryDescriptors?endTime=" + endTime + "&q=AnomalyInstance(" + parsedInfo.anomalyId + ")&startTime=" + parsedInfo.triggerTime;
    return opsa.getUrl() + metricsUri;
  };
  AnomAPI.prototype.getMetricsUrl = function (parsedInfo, descResponse) {
    var desc, descArray, endTime, now, ref;
    now = new Date().getTime();
    endTime = (ref = parsedInfo.inactiveTime) != null ? ref : now;
    descArray = JSON.parse(descResponse.body).descriptors;
    for (desc in descArray) {
      if (descArray[desc].label.startsWith("Breaches for Anomaly")) {
        return opsa.getUrl() + "/rest/getQueryResult?aqlQuery=" + encodeURIComponent(descArray[desc].aql) + "&endTime=" + endTime + '&granularity=0&pageIndex=1&paramsMap={"$starttime":"' + new Date(parsedInfo.triggerTime) + '","$limit":"1000","$interval":7200,"$offset":0,"$N":5,"$pctile":10,"$timeoffset":0,"$starttimeoffset":0,"$endtimeoffset":0,"$timeout":0,"$drill_dest":"","$drill_label":"","$drill_value":"","$drill_type":"","$problemtime":' + parsedInfo.triggerTime + ',"$aggregate_playback_flag":null}&queryType=anomalyInstance&startTime=' + parsedInfo.triggerTime + '&timeZoneOffset=-180&timeout=10';
      }
    }
  };
  AnomAPI.prototype.parseRes = function (res, requestedHost, requestedAnomalyType) {
    var anomalies, body, collection, collectionGroup, collectionGroupId, collectionId, collections, extractAnomaliesFromTable, extractInfoFromRawProps, extractSingleAnomalyData, extractedAnoms, modifyPropText, okToDisplay, propNames, table, tableIdx, toSkipAnomaly, toSkipProperty;
    body = res.body;
    anomalies = new Array();
    collections = JSON.parse(body);
    extractInfoFromRawProps = function (props, propName, propContainer) {
      var propVal;
      propVal = propContainer.displayValue;
      switch (propName) {
        case "Active time":
          props.triggerTime = propVal;
          break;
        case "Inactive time":
          props.inactiveTime = propVal;
          break;
        case "Anomaly id":
          props.anomalyId = propVal;
          break;
        case "Entity":
          props.rawEntity = propVal;
          if (propContainer.drillPQL.startsWith("host")) {
            props.anomalyType = "host";
          }
          if (propContainer.drillPQL.startsWith("service")) {
            props.anomalyType = "service";
          }
      }
      return props;
    };
    modifyPropText = function (propName, propVal, extractedInfo) {
      var idx, jsonValue;
      switch (propName) {
        case "Active time":
          propName = "Trigger Time";
          propVal = new Date(Number(propVal));
          break;
        case "Severity":
          jsonValue = JSON.parse(propVal);
          idx = Object.keys(jsonValue).length;
          propVal = jsonValue[Object.keys(jsonValue)[idx - 1]];
          break;
        case "Entity":
          if (extractedInfo.anomalyType === "host") {
            propVal = utils.getLinkToHost(propVal);
          }
      }
      return {
        propName: propName,
        propVal: propVal
      };
    };
    toSkipProperty = function (propName, extractedInfo) {
      if (propName === "Inactive time" || propName === "First breach" || propName === "Breaches timestamps" || propName === "Rules") {
        return true;
      }
      if (propName === "Entity" && extractedInfo.anomalyType === "service") {
        return true;
      }
    };
    okToDisplay = function (display, origPropName, origPropVal, extractedInfo) {
      return display === false && origPropName === "Entity" && (origPropVal === requestedHost || requestedHost === "*") && (requestedAnomalyType === extractedInfo.anomalyType);
    };
    toSkipAnomaly = function (propName, propVal) {
      return propName === "Status" && propVal !== "active";
    };
    extractSingleAnomalyData = function (anomalyRawData) {
      var anomAttr, anomalyPropertiesAsText, colIdx, curHost, mProps, ok2Display, origPropName, origPropVal;
      anomalyPropertiesAsText = "";
      ok2Display = false;
      anomAttr = {};
      anomAttr.anomalyPropertiesText = "";
      for (colIdx in anomalyRawData) {
        origPropName = propNames[colIdx];
        origPropVal = anomalyRawData[colIdx].displayValue;
        anomAttr = extractInfoFromRawProps(anomAttr, origPropName, anomalyRawData[colIdx]);
        mProps = modifyPropText(origPropName, origPropVal, anomAttr);
        if (toSkipAnomaly(mProps.propName, mProps.propVal)) {
          return null;
        }
        if (okToDisplay(ok2Display, origPropName, origPropVal, anomAttr)) {
          ok2Display = true;
        }
        if (toSkipProperty(mProps.propName, anomAttr)) {
          continue;
        }
        anomalyPropertiesAsText += "*" + mProps.propName + ":* " + mProps.propVal + "\n";
      }
      if (!ok2Display) {
        return null;
      }
      curHost = anomAttr.rawEntity;
      anomAttr.text = "\n*Displaying anomalies for " + requestedAnomalyType + ":* " + curHost + "\n>>>" + anomalyPropertiesAsText;
      return anomAttr;
    };
    extractAnomaliesFromTable = function (table) {
      var columnIdx, row, rowIdx, singleAnomaly, tableAnomalies, tableRows;
      tableAnomalies = new Array();
      for (columnIdx in table.columnNames) {
        propNames.push(table.columnNames[columnIdx].columnTitle);
      }
      tableRows = table.tableDataWithDrill;
      for (rowIdx in tableRows) {
        row = tableRows[rowIdx];
        singleAnomaly = extractSingleAnomalyData(row);
        if (singleAnomaly) {
          tableAnomalies.push(singleAnomaly);
        }
      }
      return tableAnomalies;
    };
    for (collectionGroupId in collections) {
      collectionGroup = collections[collectionGroupId];
      for (collectionId in collectionGroup) {
        collection = collectionGroup[collectionId].processedResult;
        for (tableIdx in collection) {
          table = collection[tableIdx];
          propNames = new Array();
          extractedAnoms = extractAnomaliesFromTable(table);
          anomalies = anomalies.concat(extractedAnoms);
        }
      }
    }
    return anomalies;
  };
  AnomAPI.prototype.requestMetrices = function (anom) {
    var mDescUrl, sHeaders, sJar;
    sJar = this.sJar;
    sHeaders = this.sHeaders;
    mDescUrl = AnomAPI.prototype.getMetricsDescUrl(anom);
    return utils.requestp({
      url: mDescUrl,
      jar: sJar,
      method: 'GET',
      headers: sHeaders
    }).then((function (descRes) {
      var mUrl;
      mUrl = AnomAPI.prototype.getMetricsUrl(anom, descRes);
      return utils.requestp({
        url: mUrl,
        jar: sJar,
        method: 'POST',
        headers: sHeaders
      });
    }));
  };
  AnomAPI.prototype.parseAnoms = function (userRes, anomRes) {
    var requestedAnomalyType, requestedHost;
    requestedHost = utils.getRequestedHost(userRes);
    requestedAnomalyType = utils.getRequestedAnomaliyType(userRes);
    return this.parseRes(anomRes, requestedHost, requestedAnomalyType);
  };
  module.exports = function (robot) {
    var exp, invokeAnomaliesAPI;
    invokeAnomaliesAPI = function (userRes) {
      userRes.reply(pleaseWaitMsg);
      return opsa.login().then((function (res) {
        var anomAPI;
        anomAPI = new AnomAPI(res.xsrfToken, res.jSessionId);
        return anomAPI.requestPrimaryData().then((function (anomRes) {
          var anom, anoms, i, len, results;
          anoms = anomAPI.parseAnoms(userRes, anomRes);
          utils.handleNoData(anoms, userRes);
          results = [];
          for (i = 0, len = anoms.length; i < len; i++) {
            anom = anoms[i];
            results.push(((function (anom) {
              var cAnom;
              cAnom = utils.deepClone(anom);
              return function () {
                return anomAPI.requestMetrices(cAnom).then((function (resultRes) {
                  cAnom.text += utils.getDynamicAttrsText(resultRes);
                  return userRes.reply(cAnom.text + "\n");
                }));
              };
            })(anom))());
          }
          return results;
        }));
      }));
    };
    exp = /display anomalies for (host|service)\s*:\s*(.*)/i;
    return hubotRouter.register(robot, exp, invokeAnomaliesAPI);
  };

}).call(this);
//# sourceMappingURL=opsa-hubot.js.map
